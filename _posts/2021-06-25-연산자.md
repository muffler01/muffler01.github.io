---
title: "연산자"
excerpt: "C 언어 공부, Chapter 3. 연산자"

categories:
  - C
tags:
  - C:Basic

header:
  teaser: /assets/images/etcImage/muffler.jpg

toc: true
toc_sticky: true
toc_label: "Contents"


last_modified_at: 2021-06-26T18:00
---

# 연산자

저번 Chapter 2. 타입에서는 변수와 상수, 타입의 종류와 변환에 대해서 알아보았다. 이번에는 C 언어에서 사용되는 연산자에 대해서 정리하고자 한다.  
이 글은  **Chapter 3. 연산자**을 정리한 내용이다.    
참고한 사이트 : [**TCLSchool**](http://tcpschool.com/c/c_operator_arithmetic)  

### 산술 연산자

연산자(operator)란 프로그램의 산술식이나 연산식을 표현하고 처리하기 위한 기호를 의미한다.  

1. **산술 연산자**(arithemetic operator)  
   산술 연산자는 **사칙연산을 다루는 가장 기본적인 연산자**이다. 산술 연산자는 **두 개의 피연산자를 가지는 이항 연산자**이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽이다.    

   | 산술 연산자 | 설명                                                         |
   | :---------: | :----------------------------------------------------------- |
   |      +      | 왼쪽의 피연산자에 오른쪽의 피연사자를 더함.                  |
   |      -      | 왼쪽의 피연산자에서 오픈쪽의 피연사자를 뺌.                  |
   |      *      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.                  |
   |      /      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 몫을 반환함. |
   |      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |

   ```c
   int num01 = 10;
   int num02 = 4;
   
   printf("+ 연산자에 의한 결과값은 %d입니다.\n", num01 + num02);
   printf("- 연산자에 의한 결과값은 %d입니다.\n", num01 - num02);
   printf("* 연산자에 의한 결과값은 %d입니다.\n", num01 * num02);
   printf("/ 연산자에 의한 결과값은 %d입니다.\n", num01 / num02);
   printf("% 연산자에 의한 결과값은 %d입니다.\n", num01 % num02);
   
   // 실행 결과
   + 연산자에 의한 결과값은 14입니다.
   - 연산자에 의한 결과값은 6입니다.
   * 연산자에 의한 결과값은 40입니다.
   / 연산자에 의한 결과값은 2입니다.
   % 연산자에 의한 결과값은 2입니다.
   ```

2. **연산자의 우선순위**(operator precedence)와 **결합 방향**(associativity)   
   수식 내에 여러 연산자가 동시에 존재한다면, 정해진 우선순위와 결합 방향에 의해 처리된다. **괄호(()) 연산자를 사용하여 처리 순서를 수동으로 변경**할 수도 있다.  

   | 우선 순위 | 연산자 | 설명                                   |      결합방향       |
   | :-------: | :----: | -------------------------------------- | :-----------------: |
   |     1     |   ++   | 후위 증가 연산자                       | 왼쪽에서 오른쪽으로 |
   |           |   --   | 후위 감소 연산자                       | 왼쪽에서 오른쪽으로 |
   |           |   ()   | 함수 호출                              | 왼쪽에서 오른쪽으로 |
   |           |   []   | 첨자 연산자                            | 왼쪽에서 오른쪽으로 |
   |           |   .    | 참조에 의한 선택                       | 왼쪽에서 오른쪽으로 |
   |           |   ->   | 포인터를 통한 선택                     | 왼쪽에서 오른쪽으로 |
   |     2     |   !    | 논리 NOT 연산자                        | 오른쪽에서 왼쪽으로 |
   |           |   ~    | 비트 NOT 연산자                        | 오른쪽에서 왼쪽으로 |
   |           |   +    | 양의 부호 (단항 연산자)                | 오른쪽에서 왼쪽으로 |
   |           |   -    | 음의 부호(단항 연산자)                 | 오른쪽에서 왼쪽으로 |
   |           |   ++   | 전위 증가 연산자                       | 오른쪽에서 왼쪽으로 |
   |           |   --   | 전위 감소 연산자                       | 오른쪽에서 왼쪽으로 |
   |           | (타입) | 타입 캐스트 연산자                     | 오른쪽에서 왼쪽으로 |
   |           |   *    | 참조 연산자 (단항 연산자)              | 오른쪽에서 왼쪽으로 |
   |           |   &    | 주소 연산자 (단항 연산자)              | 오른쪽에서 왼쪽으로 |
   |           | sizeof | 크기                                   | 오른쪽에서 왼쪽으로 |
   |     3     |   *    | 곱셈 연산자                            | 왼쪽에서 오른쪽으로 |
   |           |   /    | 나눗셈 연산자                          | 왼쪽에서 오른쪽으로 |
   |           |   %    | 나머지 연산자                          | 왼쪽에서 오른쪽으로 |
   |     4     |   +    | 덧셈 연산자 (이항 연산자)              | 왼쪽에서 오른쪽으로 |
   |           |   -    | 뺄셈 연산자 (이항 연산자)              | 왼쪽에서 오른쪽으로 |
   |     5     |   <<   | 비트 왼쪽 시프트 연산자                | 왼쪽에서 오른쪽으로 |
   |           |   >>   | 부호 비트를 확장 및 비트 오른쪽 시프트 | 왼쪽에서 오른쪽으로 |
   |     6     |   <    | 관계 연산자(보다 작은)                 | 왼쪽에서 오른쪽으로 |
   |           |   <=   | 관계 연산자(보다 작거나 같은)          | 왼쪽에서 오른쪽으로 |
   |           |   >    | 관계 연산자(보다 큰)                   | 왼쪽에서 오른쪽으로 |
   |           |   >=   | 관계 연산자(보다 크거나 같은)          | 왼쪽에서 오른쪽으로 |
   |     7     |   ==   | 관계 연산자(와 같은)                   | 왼쪽에서 오른쪽으로 |
   |           |   !=   | 관계 연산자(와 같지 않은)              | 왼쪽에서 오른쪽으로 |
   |     8     |   &    | 비트 AND 연산자                        | 왼쪽에서 오른쪽으로 |
   |     9     |   ^    | 비트 XOR 연산자                        | 왼쪽에서 오른쪽으로 |
   |    10     |   \|   | 비트 OR 연산자                         | 왼쪽에서 오른쪽으로 |
   |    11     |   &&   | 논리 AND 연산자                        | 왼쪽에서 오른쪽으로 |
   |    12     |  \|\|  | 논리 OR 연산자                         | 왼쪽에서 오른쪽으로 |
   |    13     |  ? :   | 삼항 조건 연산자                       | 오른쪽에서 왼쪽으로 |
   |    14     |   =    | 대입 연산자 및 복합 대입 연산자        | 오른쪽에서 왼쪽으로 |
   |    15     |   ,    | 쉼표 연산자                            | 왼쪽에서 오른쪽으로 |

   위의 표를 보면, 우선순위가 높은 연산자가 먼저 실행되고, 우선순위가 같다면 결합 순서에 따라 실행된다. **위의 표는 외우는 것이 아닌, 직접해보면서 필요할 때 참조해가며 활용하자.**

### 대입 연산자

1. **대입 연산자**(assignment operator)  
   대입 연산자는 **변수에 값을 대입할 때 사용하는 이항 연산자**이다. 피연산자들의 결합 방향은 오른쪽에서 왼쪽입니다. 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재한다. 

   | 대입 연산자 | 설명                                                         |
   | :---------: | :----------------------------------------------------------- |
   |      =      | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입                   |
   |     +=      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입 |
   |     -=      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입 |
   |     *=      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입 |
   |     /=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입 |
   |     %=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입 |

   ```c
   int num01 = 7;
   int num02 = 7;
   int num03 = 7;
   
   num01 = num01 - 5;
   num02 -= 5;
   num03 =- 5;
   
   printf("- 연산자에 의한 결과값은 %d입니다.\n", num01);
   printf("-= 연산자에 의한 결과값은 %d입니다.\n", num02);
   printf("=- 연산자에 의한 결과값은 %d입니다.\n", num03);
   
   // 실행 결과
   - 연산자에 의한 결과값은 2입니다. // num01 = 7 - 5
   -= 연산자에 의한 결과값은 2입니다. // num02 = 7 - 5 (num02 -= 5)
   =- 연산자에 의한 결과값은 -5입니다. // num03 = -5 
   ```

​		'-'와 '='의 위치를 주의하면서 코드를 작성하자.

### 증감 연산자

1. **증감 연산자**(increment and decrement operator)  
   증감 연산자란 **1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자**로, 피연산자가 하나뿐인 **단항 연산자**이다. 증감 연산자에서 **피연산자의 위치로 연산 순서, 결과가 달라지기에 주의해야 한다.**  

   | 증감 연산자 | 설명                                                        |
   | :---------: | ----------------------------------------------------------- |
   |     ++x     | 먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.    |
   |     x++     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴. |
   |     --x     | 먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.    |
   |     x--     | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴. |

   ```c
   int num01 = 7;
   int num02 = 7;
   int result01, result02;
   
   result01 = (++num01) - 5;
   result02 = (num02++) - 5;
   
   printf("전위 증가 연산자에 의한 결과값은 %d이고, 변수의 값은 %d로 변했다.\n", result01, num01);
   printf("후위 증가 연산자에 의한 결과값은 %d이고, 변수의 값은 %d로 변했다.\n", result02, num02);
   
   // 실행 결과
   전위 증가 연산자에 의한 결과값은 3이고, 변수의 값은 8로 변했다. // 7 + 1 - 5
   전위 증가 연산자에 의한 결과값은 2이고, 변수의 값은 8로 변했다. // 7 - 5 + 1
   ```

2. **증감 연산자의 연산 순서**   

   ```c
   int x = 10;
   int y = x-- + 5 + --x;
   
   printf("변수 x의 값은 %d이고, 변수 y의 값은 %d입니다.\n", x, y);
   
   // 실행 결과
   변수 x의 값은 8이고, 변수 y의 값은 23입니다.
   ```

   위의 연산 순서를 보자면,

   <p align="center">
       <img src="/assets/images/c/ch3_operation_order.png" alt="ch3_operation_order"/><br>
   ▲<i><b>연산 순서</b>, TCL</i>
   </p>

   ① : 감소 연산자가 피연산자 뒤에 있기 때문에 x + 5이 먼저 수행.   
   ② : 이후 감소 연산자. (x의 값 : 9)  
   ③ : 두 번째 감소 연산자는 피연산자 앞에 있기 때문에 --x 먼저 수행. (x의 값: 8)  
   ④ : 이후 덧셈 연산자.   
   ⑤ : 이후 대입 (y의 값 : 23)  
   **(10 + 5)(①) +(④) 10 - 1(②) - 1(③) = 23(⑤)**

### 비교 연산자

1. **비교 연산자**(comparison operator)  
   비교 연산자는 **피연산자들의 상대적인 크기를 판단하는 연산자**로, 두 개의 피연산자를 가지는 **이항 연산자**이며, 결합 방향은 **왼쪽에서 오른쪽이다.**  

   | 비교 연산자 | 설명                                                         |
   | :---------: | ------------------------------------------------------------ |
   |     ==      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환함.     |
   |     !=      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 1을 반환함. |
   |      >      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1을 반환함.     |
   |     >=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1을 반환함. |
   |      <      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1을 반환함.   |
   |     <=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1을 반환함. |

   C 언어에서 **거짓(false)은 0**이며, **0이 아닌 모든 것은 참(true)으로 인식**한다. 즉, 1을 반환하는 것은 참을 반환하는 것이다.

### 논리 연산자

1. 논리 연산자(logical operator)  
   논리 연산자는 주어진 논리식을 판단하여 참, 거짓을 결정하는 연산자이다. AND, OR, NOT 연산자가 있다. AND, OR은 이항 연산자, 결합 방향은 왼쪽에서 오른쪽이다. NOT 연산자는 단항 연산자, 결합 방향은 오른쪽에서 왼쪽이다.

   | 논리 연산자 | 설명                                                         |
   | :---------: | ------------------------------------------------------------ |
   |     &&      | 논리식이 모두 참이면 1을 반환함. (논리 AND 연산)             |
   |    \|\|     | 논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)     |
   |      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |

   A와 B 그리고 A와 B에 대한 논리 연산자에 대한 표는 다음과 같다.

   |     A     |     B     |  A && B   | A \|\| B  |    !A     |
   | :-------: | :-------: | :-------: | :-------: | :-------: |
   | 1 (true)  | 1 (true)  | 1 (true)  | 1 (true)  | 0 (false) |
   | 1 (true)  | 0 (false) | 0 (false) | 1 (true)  | 0 (false) |
   | 0 (false) | 1 (true)  | 0 (false) | 1 (true)  | 1 (true)  |
   | 0 (false) | 0 (false) | 0 (false) | 0 (false) | 1 (true)  |

   ```c
   int num01 = 3;
   int num02 = -7;
   int result01, result02;
   
   result01 = (num01 > 0) && (num01 < 5);
   result02 = (num02 < 0) || (num02 > 10);
   
   printf("&& 연산자에 의한 결과값은 %d입니다.\n", result01);
   printf("|| 연산자에 의한 결과값은 %d입니다.\n", result02);
   printf("! 연산자에 의한 결과값은 %d입니다.\n", !result02);
   
   // 실행 결과
   && 연산자에 의한 결과값은 1입니다.
   || 연산자에 의한 결과값은 1입니다.
   ! 연산자에 의한 결과값은 0입니다.
   ```

   

### 비트 연산자

### 기타 연산자 

### 추가 및 수정

- 정리할 주제
- 관련 문제 및 오류